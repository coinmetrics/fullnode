diff --git a/PATCH.md b/PATCH.md
new file mode 100644
index 000000000..8cfda9846
--- /dev/null
+++ b/PATCH.md
@@ -0,0 +1,207 @@
+# Patch: Mempool and Chain event publishers for ZMQ
+
+This is a patch-set to Bitcoin Core that adds more functionality to the ZMQ interface.
+While the patches does not touch consensus or wallet code, it's not recommended to use
+this node in a consensus critical environment where user funds are at risk.
+
+## Changes:
+
+### add: multi-payload ZMQ multipart messages
+
+A new internal function overwrite for `zmq_send_multipart()` is added.
+This allows us to send ZMQ multipart messages with a variable amount (zero to many) of payload parts.
+
+```
+ZMQ multipart message structure
+Before: | topic | payload | sequence |
+After:  | topic | timestamp | payload_0 | payload_1 | ... | payload_n | sequence |
+```
+
+### change: increase default ZMQ high water mark
+
+The previous default of 1_000 did (correctly) drop messages when publishing
+many ZMQ messages at the same time. The default high water mark is increased to
+100_000.
+
+### add: mempooladded ZMQ publisher
+
+A new ZMQ publisher with the topic `mempooladded` is added. The command line
+option `-zmqpubmempooladded=<address>` sets the address for the publisher and
+`-zmqpubmempooladdedhwm=<n>` sets a custom outbound message high water mark. The
+publisher notifies when a transaction is added to the mempool after the mempool
+is loaded and passes the txid, the raw transaction and the fee paid.
+
+The functional tests for this ZMQ publisher can be run with `python3
+test/functional/test_runner.py test/functional/interface_zmq_mempooladd.py`.
+Make sure `bitcoind` is compiled with a wallet otherwise the tests are skipped.
+
+```
+ZMQ multipart message structure
+| topic | timestamp | txid | rawtx | fee | sequence |
+```
+
+- `topic` equals `mempooladded`
+- `timestamp` are the milliseconds since 01/01/1970 as int64 in Little Endian
+- `txid` is the transaction id
+- `rawtx` is a serialized Bitcoin transaction
+- `fee` is a `int64` in Little Endian
+- `sequence` is a `uint32` in Little Endian
+
+#### Mempool-remove event with removal reason
+
+A new ZMQ publisher with the topic `mempoolremoved` is added. The command line
+option `-zmqpubmempoolremoved=<address>` sets the address for the publisher and
+`-zmqpubmempoolremovedhwm=<n>` sets a custom outbound message high water mark.
+The publisher notifies when a transaction is removed from the mempool and passes
+the txid, the raw transaction, and the removal reason.
+
+| Value | Name | Description |
+|:-----:|:----------:|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
+| 0 | Expiry | Transactions in the Mempool can expire. The default expiry timeout is 336 hours (2 weeks). |
+| 1 | Size limit | As the internal data structure storing the Mempool gets close to `maxmempool` (default 300MB) low feerate transactions are evicted. |
+| 2 | Reorg | Transactions that become invalid after a reorg are evicted. Note: Often transactions are still valid after a reorg. A transaction that might become valid is, for example, a transaction that spends a now not-mature coinbase output. |
+| 3 | Block | Transactions included in a block of the most-work chain are removed from the Mempool. |
+| 4 | Conflict | Transactions conflicting with an in-block transaction are removed. |
+| 5 | Replaced | Transactions that are replaced are removed from the Mempool.  |                                                                                                                                                                      |
+
+The functional tests for this ZMQ publisher can be run with `python3
+test/functional/test_runner.py test/functional/interface_zmq_mempoolremove*`.
+Make sure `bitcoind` is compiled with a wallet otherwise the tests are skipped.
+
+```
+ZMQ multipart message structure
+| topic | timestamp | txid | rawtx | removal reason | sequence |
+```
+
+- `topic` equals `mempoolremoved`
+- `timestamp` are the milliseconds since 01/01/1970 as int64 in Little Endian
+- `txid` is the transaction id
+- `rawtx` is a serialized Bitcoin transaction
+- `removal reason` is an `int` in Little Endian
+- `sequence` is an `uint32` in Little Endian
+
+#### Mempool-replaced event with both transactions
+
+A new ZMQ publisher with the topic `mempoolreplaced` is added. The command-line
+option `-zmqpubmempoolreplaced=<address>` sets the address for the publisher and
+`-zmqpubmempoolreplacedhwm=<n>` sets a custom outbound message high water mark.
+The publisher notifies when a transaction in the mempool is replaced. This
+includes both the transaction id and raw transaction of the replaced and the
+replacement transaction as well as their fees.
+
+The functional tests for this ZMQ publisher can be run with `python3
+test/functional/test_runner.py interface_zmq_mempoolreplace.py`.
+
+```
+ZMQ multipart message structure
+| topic | timestamp | txid replaced | rawtx replaced | fee replaced | txid replacement | rawtx replacement | fee replacement | sequence |
+```
+
+- `topic` equals `mempoolreplaced`
+- `timestamp` are the milliseconds since 01/01/1970 as int64 in Little Endian
+- `txid replaced` is the txid of the replaced transaction
+- `rawtx replaced` is the serialized Bitcoin transaction that is replaced
+- `fee replaced` is the fee of the replaced transaction as a `int64_t` in Little Endian
+- `txid replacement` is the txid of the replacement transaction
+- `rawtx replacement` is the serialized Bitcoin transaction that is the replacement
+- `fee replacement` is the fee of the replacement transaction as a `int64_t` in Little Endian
+- `sequence` is an `uint32` in Little Endian
+
+#### Mempool-confirmed event with block header and height
+
+A new ZMQ publisher with the topic `mempoolconfirmed` is added. The command line
+option `-zmqpubmempoolconfirmed=<address>` sets the address for the publisher
+and `-zmqpubmempoolconfirmedhwm=<n>` sets a custom outbound message high water
+mark. The publisher notifies when a transaction is included in a block and
+passes the txid, the raw transaction, the block height and the block hash.
+
+The functional tests for this ZMQ publisher can be run with `python3
+test/functional/test_runner.py
+test/functional/interface_zmq_mempoolconfirmed.py`. Make sure bitcoind is
+compiled with a wallet otherwise the tests are skipped.
+
+```
+ZMQ multipart message structure
+| topic | timestamp | txid | rawtx | block height | block hash | header | sequence |
+```
+
+- `topic` equals `mempoolconfirmed`
+- `timestamp` are the milliseconds since 01/01/1970 as int64 in Little Endian
+- `txid` is the transaction id
+- `rawtx` is a serialized Bitcoin transaction
+- `block height` is the block height as `int32` in Little Endian
+- `block hash` is the block hash
+- `header` is the 80-byte serialized block header
+- `sequence` is a `uint32` in Little Endian
+
+#### Chain-tipchanged event with height and header
+
+A new ZMQ publisher with the topic `chaintipchanged` is added. The command-line
+option `-zmqpubchaintipchanged=<address>` sets the address for the publisher and
+`-zmqpubchaintipchangedhwm=<n>` sets a custom outbound message high water mark.
+The publisher notifies when a block is connected to a branch on a chain. Note:
+This block does not need to be the the most-work chain.
+
+The functional tests for this ZMQ publisher can be run with `python3
+test/functional/test_runner.py interface_zmq_chaintipchanged.py`.
+
+#### Specification
+```
+ZMQ multipart message structure
+| topic | timestamp | hash | height | header | sequence |
+```
+
+- `topic` equals `chaintipchanged`
+- `timestamp` are the milliseconds since 01/01/1970 as int64 in Little Endian
+- `hash` is the block hash
+- `height` is the block height as `int32` in Little Endian
+- `header` is the 80-byte serialized block header
+- `sequence` is an `uint32` in Little Endian
+
+#### Chain-connected event with raw block
+
+A new ZMQ publisher with the topic `chainconnected` is added. The command-line
+option `-zmqpubchainconnected=<address>` sets the address for the publisher and
+`-zmqpubchainconnectedhwm=<n>` sets a custom outbound message high water mark.
+The publisher notifies when a block is connected to a branch on a chain. Note:
+This block does not need to be the the most-work chain.
+
+The functional tests for this ZMQ publisher can be run with `python3
+test/functional/test_runner.py interface_zmq_chainblockconnected.py`.
+
+```
+ZMQ multipart message structure
+| topic | timestamp | hash | height | prev hash | rawblock | sequence |
+```
+
+- `topic` equals `chainconnected`
+- `timestamp` are the milliseconds since 01/01/1970 as int64 in Little Endian
+- `hash` is the block hash
+- `height` is the block height as `int32` in Little Endian
+- `prev hash` is the previous block hash
+- `block` is a serialized Bitcoin block
+- `sequence` is an `uint32` in Little Endian
+
+#### Chain-headeradded event with height and header
+
+A new ZMQ publisher with the topic `chainheaderadded` is added. The command-line
+option `-zmqpubchainheaderadded=<address>` sets the address for the publisher
+and `-zmqpubchainheaderaddedhwm=<n>` sets a custom outbound message high water
+mark. The publisher notifies when a header is connected to a branch on a chain.
+Note: This header addition does not need to be on the the most-work chain.
+
+The functional tests for this ZMQ publisher can be run with `python3
+test/functional/test_runner.py interface_zmq_chainheaderadded.py`.
+
+```
+ZMQ multipart message structure
+| topic | timestamp | hash | height | header | sequence |
+```
+
+- `topic` equals `chainheaderadded`
+- `timestamp` are the milliseconds since 01/01/1970 as int64 in Little Endian
+- `hash` is the block hash
+- `height` is the block height as `int32` in Little Endian
+- `header` is the 80-byte serialized block header
+- `sequence` is an `uint32` in Little Endian
+
diff --git a/src/init.cpp b/src/init.cpp
index 9afd76d62..92789ebf6 100644
--- a/src/init.cpp
+++ b/src/init.cpp
@@ -486,6 +486,21 @@ void SetupServerArgs(ArgsManager& argsman)
     argsman.AddArg("-zmqpubrawblockhwm=<n>", strprintf("Set publish raw block outbound message high water mark (default: %d)", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
     argsman.AddArg("-zmqpubrawtxhwm=<n>", strprintf("Set publish raw transaction outbound message high water mark (default: %d)", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
     argsman.AddArg("-zmqpubsequencehwm=<n>", strprintf("Set publish hash sequence message high water mark (default: %d)", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
+
+    argsman.AddArg("-zmqpubmempooladded=<address>", "Enable publish raw transaction with fee in <address>", ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
+    argsman.AddArg("-zmqpubmempooladdedhwm=<n>", strprintf("Set publish raw transaction with fee outbound message high water mark (default: %d)", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
+    argsman.AddArg("-zmqpubmempoolremoved=<address>", "Enable publish removed raw transaction with reason in <address>", ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
+    argsman.AddArg("-zmqpubmempoolremovedhwm=<n>", strprintf("Set publish removed raw transaction with reason outbound message high water mark (default: %d)", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
+    argsman.AddArg("-zmqpubmempoolreplaced=<address>", "Enable publish of replaced and replacement raw transaction with their fees in <address>", ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
+    argsman.AddArg("-zmqpubmempoolreplacedhwm=<n>", strprintf("Set publish of replaced and replacement raw transaction with their fees outbound message high water mark (default: %d)", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
+    argsman.AddArg("-zmqpubmempoolconfirmed=<address>", "Enable publish of confirmed transactions with the height and block header in <address>", ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
+    argsman.AddArg("-zmqpubmempoolconfirmedhwm=<n>", strprintf("Set outbound message high water mark for confirmed transactions (default: %d)", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
+    argsman.AddArg("-zmqpubchaintipchanged=<address>", "Enable publish tip changed events in <address>", ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
+    argsman.AddArg("-zmqpubchaintipchangedhwm=<n>", strprintf("Set tip changed outbound message high water mark (default: %d)", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
+    argsman.AddArg("-zmqpubchainconnected=<address>", "Enable publish raw block connected in <address>", ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
+    argsman.AddArg("-zmqpubchainconnectedhwm=<n>", strprintf("Set publish raw block connected outbound message high water mark (default: %d)", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
+    argsman.AddArg("-zmqpubchainheaderadded=<address>", "Enable publish header added events in <address>", ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
+    argsman.AddArg("-zmqpubchainheaderaddedhwm=<n>", strprintf("Set header added outbound message high water mark (default: %d)", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
 #else
     hidden_args.emplace_back("-zmqpubhashblock=<address>");
     hidden_args.emplace_back("-zmqpubhashtx=<address>");
@@ -497,6 +512,21 @@ void SetupServerArgs(ArgsManager& argsman)
     hidden_args.emplace_back("-zmqpubrawblockhwm=<n>");
     hidden_args.emplace_back("-zmqpubrawtxhwm=<n>");
     hidden_args.emplace_back("-zmqpubsequencehwm=<n>");
+
+    hidden_args.emplace_back("-zmqpubmempooladded=<address>");
+    hidden_args.emplace_back("-zmqpubmempooladdedhwm=<n>");
+    hidden_args.emplace_back("-zmqpubmempoolremoved=<address>");
+    hidden_args.emplace_back("-zmqpubmempoolremovedhwm=<address>");
+    hidden_args.emplace_back("-zmqpubmempoolreplaced=<address>");
+    hidden_args.emplace_back("-zmqpubmempoolreplacedhwm=<address>");
+    hidden_args.emplace_back("-zmqpubmempoolconfirmed=<address>");
+    hidden_args.emplace_back("-zmqpubmempoolconfirmedhwm=<n>");
+    hidden_args.emplace_back("-zmqpubchaintipchanged=<address>");
+    hidden_args.emplace_back("-zmqpubchaintipchangedhwm=<address>");
+    hidden_args.emplace_back("-zmqpubchainconnected=<address>");
+    hidden_args.emplace_back("-zmqpubchainconnectedhwm=<address>");
+    hidden_args.emplace_back("-zmqpubchainheaderadded=<address>");
+    hidden_args.emplace_back("-zmqpubchainheaderaddedhwm=<address>");
 #endif
 
     argsman.AddArg("-checkblocks=<n>", strprintf("How many blocks to check at startup (default: %u, 0 = all)", DEFAULT_CHECKBLOCKS), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);
diff --git a/src/interfaces/chain.h b/src/interfaces/chain.h
index 7cac435e9..392fe3cd5 100644
--- a/src/interfaces/chain.h
+++ b/src/interfaces/chain.h
@@ -235,6 +235,8 @@ public:
     public:
         virtual ~Notifications() {}
         virtual void transactionAddedToMempool(const CTransactionRef& tx, uint64_t mempool_sequence) {}
+        virtual void transactionAddedToMempoolFee(const CTransactionRef& tx, const CAmount fee) {}
+        virtual void transactionReplacedInMempool(const CTransactionRef& tx_replaced, const CAmount fee_replaced, const CTransactionRef& tx_replacement, const CAmount fee_replacement) {}
         virtual void transactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t mempool_sequence) {}
         virtual void blockConnected(const CBlock& block, int height) {}
         virtual void blockDisconnected(const CBlock& block, int height) {}
diff --git a/src/node/interfaces.cpp b/src/node/interfaces.cpp
index 183b5a5d9..e165e2bbc 100644
--- a/src/node/interfaces.cpp
+++ b/src/node/interfaces.cpp
@@ -347,10 +347,18 @@ public:
     {
         m_notifications->transactionAddedToMempool(tx, mempool_sequence);
     }
+    void TransactionAddedToMempoolFee(const CTransactionRef& tx, const CAmount fee) override
+    {
+        m_notifications->transactionAddedToMempoolFee(tx, fee);
+    }
     void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t mempool_sequence) override
     {
         m_notifications->transactionRemovedFromMempool(tx, reason, mempool_sequence);
     }
+    void TransactionReplacedInMempool(const CTransactionRef& tx_replaced, const CAmount fee_replaced, const CTransactionRef& tx_replacement, const CAmount fee_replacement) override
+    {
+        m_notifications->transactionReplacedInMempool(tx_replaced, fee_replaced, tx_replacement, fee_replacement);
+    }
     void BlockConnected(const std::shared_ptr<const CBlock>& block, const CBlockIndex* index) override
     {
         m_notifications->blockConnected(*block, index->nHeight);
diff --git a/src/validation.cpp b/src/validation.cpp
index 26333d702..80e7f961c 100644
--- a/src/validation.cpp
+++ b/src/validation.cpp
@@ -995,6 +995,7 @@ bool MemPoolAccept::Finalize(const ATMPArgs& args, Workspace& ws)
                 hash.ToString(),
                 FormatMoney(nModifiedFees - nConflictingFees),
                 (int)entry->GetTxSize() - (int)nConflictingSize);
+        GetMainSignals().TransactionReplacedInMempool(it->GetSharedTx(), nConflictingFees, ws.m_ptx, nModifiedFees);
         ws.m_replaced_transactions.push_back(it->GetSharedTx());
     }
     m_pool.RemoveStaged(allConflicting, false, MemPoolRemovalReason::REPLACED);
@@ -1045,6 +1046,7 @@ MempoolAcceptResult MemPoolAccept::AcceptSingleTransaction(const CTransactionRef
     if (!Finalize(args, ws)) return MempoolAcceptResult::Failure(ws.m_state);
 
     GetMainSignals().TransactionAddedToMempool(ptx, m_pool.GetAndIncrementSequence());
+    GetMainSignals().TransactionAddedToMempoolFee(ptx, ws.m_entry->GetFee());
 
     return MempoolAcceptResult::Success(std::move(ws.m_replaced_transactions), ws.m_base_fees);
 }
@@ -2953,6 +2955,10 @@ CBlockIndex* BlockManager::AddToBlockIndex(const CBlockHeader& block)
 
     setDirtyBlockIndex.insert(pindexNew);
 
+    if (!fImporting && !fReindex) {
+        GetMainSignals().HeaderAddedToChain(pindexNew);
+    }
+
     return pindexNew;
 }
 
diff --git a/src/validationinterface.cpp b/src/validationinterface.cpp
index 1e07ff23a..c900f7fe6 100644
--- a/src/validationinterface.cpp
+++ b/src/validationinterface.cpp
@@ -208,6 +208,15 @@ void CMainSignals::TransactionAddedToMempool(const CTransactionRef& tx, uint64_t
                           tx->GetWitnessHash().ToString());
 }
 
+void CMainSignals::TransactionAddedToMempoolFee(const CTransactionRef& tx, const CAmount fee) {
+    auto event = [tx, fee, this] {
+        m_internals->Iterate([&](CValidationInterface& callbacks) { callbacks.TransactionAddedToMempoolFee(tx, fee); });
+    };
+    ENQUEUE_AND_LOG_EVENT(event, "%s: txid=%s wtxid=%s", __func__,
+                          tx->GetHash().ToString(),
+                          tx->GetWitnessHash().ToString());
+}
+
 void CMainSignals::TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t mempool_sequence) {
     auto event = [tx, reason, mempool_sequence, this] {
         m_internals->Iterate([&](CValidationInterface& callbacks) { callbacks.TransactionRemovedFromMempool(tx, reason, mempool_sequence); });
@@ -217,6 +226,24 @@ void CMainSignals::TransactionRemovedFromMempool(const CTransactionRef& tx, MemP
                           tx->GetWitnessHash().ToString());
 }
 
+void CMainSignals::TransactionReplacedInMempool(const CTransactionRef& tx_replaced, const CAmount fee_replaced, const CTransactionRef& tx_replacement, const CAmount fee_replacement) {
+    auto event = [tx_replaced, fee_replaced, tx_replacement, fee_replacement, this] {
+        m_internals->Iterate([&](CValidationInterface& callbacks) { callbacks.TransactionReplacedInMempool(tx_replaced, fee_replaced, tx_replacement, fee_replacement); });
+    };
+    ENQUEUE_AND_LOG_EVENT(event, "%s: txid_replaced=%s txid_replacement=%s", __func__,
+                          tx_replaced->GetHash().ToString(),
+                          tx_replacement->GetHash().ToString());
+}
+
+void CMainSignals::HeaderAddedToChain(const CBlockIndex *pindexHeader) {
+    auto event = [pindexHeader, this] {
+        m_internals->Iterate([&](CValidationInterface& callbacks) { callbacks.HeaderAddedToChain(pindexHeader); });
+    };
+    ENQUEUE_AND_LOG_EVENT(event, "%s: block hash=%s block height=%d", __func__,
+                        pindexHeader->GetBlockHash().ToString(),
+                        pindexHeader->nHeight);
+}
+
 void CMainSignals::BlockConnected(const std::shared_ptr<const CBlock> &pblock, const CBlockIndex *pindex) {
     auto event = [pblock, pindex, this] {
         m_internals->Iterate([&](CValidationInterface& callbacks) { callbacks.BlockConnected(pblock, pindex); });
diff --git a/src/validationinterface.h b/src/validationinterface.h
index 7c3ce00fb..ce5448a39 100644
--- a/src/validationinterface.h
+++ b/src/validationinterface.h
@@ -98,7 +98,18 @@ protected:
      * Called on a background thread.
      */
     virtual void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t mempool_sequence) {}
-
+    /**
+     * Notifies listeners of a transaction having been added to mempool. Includes the transaction fee.
+     *
+     * Called on a background thread.
+     */
+    virtual void TransactionAddedToMempoolFee(const CTransactionRef& tx, const CAmount fee) {}
+    /**
+     * Notifies listeners of a transaction having been replaced in the mempool. Includes the transaction fees.
+     *
+     * Called on a background thread.
+     */
+    virtual void TransactionReplacedInMempool(const CTransactionRef& tx_replaced, const CAmount fee_replaced, const CTransactionRef& tx_replacement, const CAmount fee_replacement) {}
     /**
      * Notifies listeners of a transaction leaving mempool.
      *
@@ -139,6 +150,12 @@ protected:
      * Called on a background thread.
      */
     virtual void BlockConnected(const std::shared_ptr<const CBlock> &block, const CBlockIndex *pindex) {}
+    /**
+     * Notifies listeners when a new header is added to one of the branches of the chain.
+     *
+     * Called on a background thread.
+     */
+    virtual void HeaderAddedToChain(const CBlockIndex *pindexHeader) {}
     /**
      * Notifies listeners of a block being disconnected
      *
@@ -199,8 +216,11 @@ public:
 
     void UpdatedBlockTip(const CBlockIndex *, const CBlockIndex *, bool fInitialDownload);
     void TransactionAddedToMempool(const CTransactionRef&, uint64_t mempool_sequence);
+    void TransactionAddedToMempoolFee(const CTransactionRef&, const CAmount fee);
     void TransactionRemovedFromMempool(const CTransactionRef&, MemPoolRemovalReason, uint64_t mempool_sequence);
+    void TransactionReplacedInMempool(const CTransactionRef&, const CAmount, const CTransactionRef&, const CAmount);
     void BlockConnected(const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex);
+    void HeaderAddedToChain(const CBlockIndex *);
     void BlockDisconnected(const std::shared_ptr<const CBlock> &, const CBlockIndex* pindex);
     void ChainStateFlushed(const CBlockLocator &);
     void BlockChecked(const CBlock&, const BlockValidationState&);
diff --git a/src/zmq/zmqabstractnotifier.cpp b/src/zmq/zmqabstractnotifier.cpp
index 90aefb001..fb970c955 100644
--- a/src/zmq/zmqabstractnotifier.cpp
+++ b/src/zmq/zmqabstractnotifier.cpp
@@ -23,6 +23,11 @@ bool CZMQAbstractNotifier::NotifyTransaction(const CTransaction &/*transaction*/
     return true;
 }
 
+bool CZMQAbstractNotifier::NotifyTransactionFee(const CTransaction &/*transaction*/, const CAmount fee)
+{
+    return true;
+}
+
 bool CZMQAbstractNotifier::NotifyBlockConnect(const CBlockIndex * /*CBlockIndex*/)
 {
     return true;
@@ -42,3 +47,33 @@ bool CZMQAbstractNotifier::NotifyTransactionRemoval(const CTransaction &/*transa
 {
     return true;
 }
+
+bool CZMQAbstractNotifier::NotifyTransactionRemovalReason(const CTransaction &/*transaction*/, const MemPoolRemovalReason reason)
+{
+    return true;
+}
+
+bool CZMQAbstractNotifier::NotifyTransactionReplaced(const CTransaction &/* replaced tx */, const CAmount/*replaced fee*/, const CTransaction&/*replacement tx*/, const CAmount/*replacement fee*/)
+{
+    return true;
+}
+
+bool CZMQAbstractNotifier::NotifyMempoolTransactionConfirmed(const CTransaction &/*transaction*/, const CBlockIndex *)
+{
+    return true;
+}
+
+bool CZMQAbstractNotifier::NotifyChainTipChanged(const CBlockIndex *)
+{
+    return true;
+}
+
+bool CZMQAbstractNotifier::NotifyChainBlockConnected(const CBlockIndex *)
+{
+    return true;
+}
+
+bool CZMQAbstractNotifier::NotifyChainHeaderAdded(const CBlockIndex *)
+{
+    return true;
+}
diff --git a/src/zmq/zmqabstractnotifier.h b/src/zmq/zmqabstractnotifier.h
index 49c1c2a07..5abf3b36f 100644
--- a/src/zmq/zmqabstractnotifier.h
+++ b/src/zmq/zmqabstractnotifier.h
@@ -12,13 +12,15 @@
 class CBlockIndex;
 class CTransaction;
 class CZMQAbstractNotifier;
+typedef int64_t CAmount;
+enum class MemPoolRemovalReason;
 
 using CZMQNotifierFactory = std::unique_ptr<CZMQAbstractNotifier> (*)();
 
 class CZMQAbstractNotifier
 {
 public:
-    static const int DEFAULT_ZMQ_SNDHWM {1000};
+    static const int DEFAULT_ZMQ_SNDHWM {100000};
 
     CZMQAbstractNotifier() : psocket(nullptr), outbound_message_high_water_mark(DEFAULT_ZMQ_SNDHWM) { }
     virtual ~CZMQAbstractNotifier();
@@ -53,9 +55,22 @@ public:
     virtual bool NotifyTransactionAcceptance(const CTransaction &transaction, uint64_t mempool_sequence);
     // Notifies of every mempool removal, except inclusion in blocks
     virtual bool NotifyTransactionRemoval(const CTransaction &transaction, uint64_t mempool_sequence);
+    // Notifies of every mempool removal, including inclusion in blocks. Includes the removal reason.
+    virtual bool NotifyTransactionRemovalReason(const CTransaction &transaction, const MemPoolRemovalReason reason);
     // Notifies of transactions added to mempool or appearing in blocks
     virtual bool NotifyTransaction(const CTransaction &transaction);
-
+    // Notifies of transactions added to mempool (only!) with the transaction fee.
+    virtual bool NotifyTransactionFee(const CTransaction &transaction, const CAmount fee);
+    // Notifies of transactions replaced in the mempool.
+    virtual bool NotifyTransactionReplaced(const CTransaction &tx_replaced, const CAmount fee_replaced, const CTransaction &tx_replacement, const CAmount fee_replacement);
+    // Notifies of transactions confirmed with information about the block.
+    virtual bool NotifyMempoolTransactionConfirmed(const CTransaction &transaction, const CBlockIndex *pindex);
+    // Notifies of changed chain tips.
+    virtual bool NotifyChainTipChanged(const CBlockIndex *pindex);
+    // Notifies of a block connection to the chain.
+    virtual bool NotifyChainBlockConnected(const CBlockIndex *pindex);
+    // Notifies of a header connection to the chian.
+    virtual bool NotifyChainHeaderAdded(const CBlockIndex *pindex);
 protected:
     void *psocket;
     std::string type;
diff --git a/src/zmq/zmqnotificationinterface.cpp b/src/zmq/zmqnotificationinterface.cpp
index 86f47d71f..9e964a096 100644
--- a/src/zmq/zmqnotificationinterface.cpp
+++ b/src/zmq/zmqnotificationinterface.cpp
@@ -38,6 +38,14 @@ CZMQNotificationInterface* CZMQNotificationInterface::Create()
     factories["pubrawtx"] = CZMQAbstractNotifier::Create<CZMQPublishRawTransactionNotifier>;
     factories["pubsequence"] = CZMQAbstractNotifier::Create<CZMQPublishSequenceNotifier>;
 
+    factories["pubmempooladded"] = CZMQAbstractNotifier::Create<CZMQPublishMempolAddedNotifier>;
+    factories["pubmempoolremoved"] = CZMQAbstractNotifier::Create<CZMQPublishMempoolRemovedNotifier>;
+    factories["pubmempoolreplaced"] = CZMQAbstractNotifier::Create<CZMQPublishMempoolReplacedNotifier>;
+    factories["pubmempoolconfirmed"] = CZMQAbstractNotifier::Create<CZMQPublishMempoolConfirmedNotifier>;
+    factories["pubchaintipchanged"] = CZMQAbstractNotifier::Create<CZMQPublishChainTipChangedNotifier>;
+    factories["pubchainconnected"] = CZMQAbstractNotifier::Create<CZMQPublishChainConnectedNotifier>;
+    factories["pubchainheaderadded"] = CZMQAbstractNotifier::Create<CZMQPublishChainHeaderAddedNotifier>;
+
     std::list<std::unique_ptr<CZMQAbstractNotifier>> notifiers;
     for (const auto& entry : factories)
     {
@@ -137,6 +145,10 @@ void CZMQNotificationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, co
     TryForEachAndRemoveFailed(notifiers, [pindexNew](CZMQAbstractNotifier* notifier) {
         return notifier->NotifyBlock(pindexNew);
     });
+
+    TryForEachAndRemoveFailed(notifiers, [pindexNew](CZMQAbstractNotifier* notifier) {
+        return notifier->NotifyChainTipChanged(pindexNew);
+    });
 }
 
 void CZMQNotificationInterface::TransactionAddedToMempool(const CTransactionRef& ptx, uint64_t mempool_sequence)
@@ -148,6 +160,15 @@ void CZMQNotificationInterface::TransactionAddedToMempool(const CTransactionRef&
     });
 }
 
+void CZMQNotificationInterface::TransactionAddedToMempoolFee(const CTransactionRef& ptx, const CAmount fee)
+{
+    const CTransaction& tx = *ptx;
+
+    TryForEachAndRemoveFailed(notifiers, [&tx, fee](CZMQAbstractNotifier* notifier) {
+        return notifier->NotifyTransactionFee(tx, fee);
+    });
+}
+
 void CZMQNotificationInterface::TransactionRemovedFromMempool(const CTransactionRef& ptx, MemPoolRemovalReason reason, uint64_t mempool_sequence)
 {
     // Called for all non-block inclusion reasons
@@ -156,6 +177,20 @@ void CZMQNotificationInterface::TransactionRemovedFromMempool(const CTransaction
     TryForEachAndRemoveFailed(notifiers, [&tx, mempool_sequence](CZMQAbstractNotifier* notifier) {
         return notifier->NotifyTransactionRemoval(tx, mempool_sequence);
     });
+
+    TryForEachAndRemoveFailed(notifiers, [&tx, reason](CZMQAbstractNotifier* notifier) {
+        return notifier->NotifyTransactionRemovalReason(tx, reason);
+    });
+}
+
+void CZMQNotificationInterface::TransactionReplacedInMempool(const CTransactionRef& txref_replaced, const CAmount fee_replaced, const CTransactionRef& txref_replacement, const CAmount fee_replacement)
+{
+    const CTransaction& tx_replaced = *txref_replaced;
+    const CTransaction& tx_replacement = *txref_replacement;
+
+    TryForEachAndRemoveFailed(notifiers, [&tx_replaced, fee_replaced, &tx_replacement, fee_replacement](CZMQAbstractNotifier* notifier) {
+        return notifier->NotifyTransactionReplaced(tx_replaced, fee_replaced, tx_replacement, fee_replacement);
+    });
 }
 
 void CZMQNotificationInterface::BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexConnected)
@@ -165,12 +200,26 @@ void CZMQNotificationInterface::BlockConnected(const std::shared_ptr<const CBloc
         TryForEachAndRemoveFailed(notifiers, [&tx](CZMQAbstractNotifier* notifier) {
             return notifier->NotifyTransaction(tx);
         });
+
+        // do not notify on coinbase tx
+        if (tx.IsCoinBase()) continue;
+        TryForEachAndRemoveFailed(notifiers, [&tx](CZMQAbstractNotifier* notifier) {
+          return notifier->NotifyTransactionRemovalReason(tx, MemPoolRemovalReason::BLOCK);
+        });
+        TryForEachAndRemoveFailed(notifiers, [&tx, pindexConnected](CZMQAbstractNotifier* notifier) {
+          return notifier->NotifyMempoolTransactionConfirmed(tx, pindexConnected);
+        });
     }
 
     // Next we notify BlockConnect listeners for *all* blocks
     TryForEachAndRemoveFailed(notifiers, [pindexConnected](CZMQAbstractNotifier* notifier) {
         return notifier->NotifyBlockConnect(pindexConnected);
     });
+
+    TryForEachAndRemoveFailed(notifiers, [pindexConnected](CZMQAbstractNotifier* notifier) {
+        return notifier->NotifyChainBlockConnected(pindexConnected);
+    });
+
 }
 
 void CZMQNotificationInterface::BlockDisconnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexDisconnected)
@@ -188,4 +237,11 @@ void CZMQNotificationInterface::BlockDisconnected(const std::shared_ptr<const CB
     });
 }
 
+void CZMQNotificationInterface::HeaderAddedToChain(const CBlockIndex *pindexHeader)
+{
+    TryForEachAndRemoveFailed(notifiers, [pindexHeader](CZMQAbstractNotifier* notifier) {
+        return notifier->NotifyChainHeaderAdded(pindexHeader);
+    });
+}
+
 CZMQNotificationInterface* g_zmq_notification_interface = nullptr;
diff --git a/src/zmq/zmqnotificationinterface.h b/src/zmq/zmqnotificationinterface.h
index 8f81bfd63..7ab845334 100644
--- a/src/zmq/zmqnotificationinterface.h
+++ b/src/zmq/zmqnotificationinterface.h
@@ -32,6 +32,9 @@ protected:
     void BlockDisconnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexDisconnected) override;
     void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) override;
 
+    void TransactionAddedToMempoolFee(const CTransactionRef& tx, const CAmount fee) override;
+    void TransactionReplacedInMempool(const CTransactionRef& tx_replaced, const CAmount fee_replaced, const CTransactionRef& tx_replacement, const CAmount fee_replacement) override;
+    void HeaderAddedToChain(const CBlockIndex *pindexHeader) override;
 private:
     CZMQNotificationInterface();
 
diff --git a/src/zmq/zmqpublishnotifier.cpp b/src/zmq/zmqpublishnotifier.cpp
index 6ae866cc0..3aa81688f 100644
--- a/src/zmq/zmqpublishnotifier.cpp
+++ b/src/zmq/zmqpublishnotifier.cpp
@@ -30,6 +30,14 @@ static const char *MSG_RAWBLOCK  = "rawblock";
 static const char *MSG_RAWTX     = "rawtx";
 static const char *MSG_SEQUENCE  = "sequence";
 
+static const char *MSG_MEMPOOLADDED = "mempooladded";
+static const char *MSG_MEMPOOLREMOVED = "mempoolremoved";
+static const char *MSG_MEMPOOLREPLACED = "mempoolreplaced";
+static const char *MSG_MEMPOOLCONFIRMED = "mempoolconfirmed";
+static const char *MSG_CHAINTIPCHANGED = "chaintipchanged";
+static const char *MSG_CHAINCONNECTED = "chainconnected";
+static const char *MSG_CHAINHEADERADDED = "chainheaderadded";
+
 // Internal function to send multipart message
 static int zmq_send_multipart(void *sock, const void* data, size_t size, ...)
 {
@@ -73,6 +81,78 @@ static int zmq_send_multipart(void *sock, const void* data, size_t size, ...)
     return 0;
 }
 
+static int zmq_send_multipart(void *sock, const zmq_message& message)
+{
+    for (size_t i = 0; i < message.size(); i++) {
+        auto const& part = message[i];
+        zmq_msg_t msg;
+
+        int rc = zmq_msg_init_size(&msg, part.size());
+        if (rc != 0) {
+            zmqError("Unable to initialize ZMQ msg");
+            return -1;
+        }
+
+        void* buf = zmq_msg_data(&msg);
+        std::memcpy(buf, part.data(), part.size());
+
+        rc = zmq_msg_send(&msg, sock, (i < (message.size() - 1)) ? ZMQ_SNDMORE : 0);
+        if (rc == -1) {
+            zmqError("Unable to send ZMQ msg");
+            zmq_msg_close(&msg);
+            return -1;
+        }
+
+        zmq_msg_close(&msg);
+    }
+
+    LogPrint(BCLog::ZMQ, "sent message with %d parts\n", message.size());
+    return 0;
+}
+
+// converts an uint256 hash into a zmq_message_part (hash is reversed)
+static zmq_message_part hashToZMQMessagePart(const uint256 hash) {
+    zmq_message_part part_hash;
+    for (int i = 31; i >= 0; i--)
+        part_hash.push_back(hash.begin()[i]);
+    return part_hash;
+}
+
+// converts a CTransaction into a zmq_message_part (by serializing it)
+static zmq_message_part transactionToZMQMessagePart(const CTransaction& transaction) {
+    CDataStream ss_replaced(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());
+    ss_replaced << transaction;
+    return zmq_message_part(ss_replaced.begin() , ss_replaced.end());
+}
+
+// converts an int64_t into a zmq_message_part
+static zmq_message_part int64ToZMQMessagePart(const int64_t val) {
+    const size_t size = sizeof(int64_t);
+    unsigned char value[size];
+    std::memcpy(value, &val, size);
+    return zmq_message_part(value, value + size);
+}
+
+// returns the current time in milliseconds as zmq_message_part
+static zmq_message_part getCurrentTimeMillis() {
+    return zmq_message_part(int64ToZMQMessagePart(GetTimeMillis()));
+}
+
+// converts a header into a zmq_message_part
+static zmq_message_part headerToZMQMessagePart(const CBlockHeader& header) {
+    CDataStream ss_header(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());
+    ss_header << header;
+    return zmq_message_part(ss_header.begin() , ss_header.end());
+}
+
+// converts an int32_t into a zmq_message_part
+static zmq_message_part int32ToZMQMessagePart(const int32_t val) {
+    const size_t size = sizeof(int32_t);
+    unsigned char value[size];
+    std::memcpy(value, &val, size);
+    return zmq_message_part(value, value + size);
+}
+
 bool CZMQAbstractPublishNotifier::Initialize(void *pcontext)
 {
     assert(!psocket);
@@ -179,6 +259,36 @@ bool CZMQAbstractPublishNotifier::SendZmqMessage(const char *command, const void
     return true;
 }
 
+bool CZMQAbstractPublishNotifier::SendZmqMessage(const char *command, const std::vector<zmq_message_part>& payload)
+{
+    assert(psocket);
+
+    /*
+      create message from multiple parts:
+       - first part is the command (or topic)
+       - second part is the current timestamp
+       - followed by one or multiple payload parts
+       - ended by a LE 4 byte sequence number
+    */
+    std::vector<zmq_message_part> message = {};
+    message.push_back(zmq_message_part(command, command + strlen(command)));
+    message.push_back(getCurrentTimeMillis());
+    for (size_t i = 0; i < payload.size(); i++)
+        message.push_back(payload[i]);
+    unsigned char sequenceLE[sizeof(uint32_t)];
+    WriteLE32(&sequenceLE[0], nSequence);
+    message.push_back(zmq_message_part(sequenceLE, sequenceLE + sizeof(uint32_t)));
+
+    int rc = zmq_send_multipart(psocket, message);
+    if (rc == -1)
+        return false;
+
+    // increment memory only sequence number after sending
+    nSequence++;
+
+    return true;
+}
+
 bool CZMQPublishHashBlockNotifier::NotifyBlock(const CBlockIndex *pindex)
 {
     uint256 hash = pindex->GetBlockHash();
@@ -269,3 +379,118 @@ bool CZMQPublishSequenceNotifier::NotifyTransactionRemoval(const CTransaction &t
     LogPrint(BCLog::ZMQ, "zmq: Publish hashtx mempool removal %s to %s\n", hash.GetHex(), this->address);
     return SendSequenceMsg(*this, hash, /* Mempool (R)emoval */ 'R', mempool_sequence);
 }
+
+bool CZMQPublishMempolAddedNotifier::NotifyTransactionFee(const CTransaction &transaction, const CAmount fee)
+{
+    uint256 txid = transaction.GetHash();
+    LogPrint(BCLog::ZMQ, "zmq: Publish mempooladded %s\n", txid.GetHex());
+
+    std::vector<zmq_message_part> payload = {};
+    payload.push_back(hashToZMQMessagePart(txid));
+    payload.push_back(transactionToZMQMessagePart(transaction));
+    payload.push_back(int64ToZMQMessagePart(fee));
+
+    return SendZmqMessage(MSG_MEMPOOLADDED, payload);
+}
+
+bool CZMQPublishMempoolRemovedNotifier::NotifyTransactionRemovalReason(const CTransaction &transaction, const MemPoolRemovalReason reason)
+{
+    uint256 txid = transaction.GetHash();
+    LogPrint(BCLog::ZMQ, "zmq: Publish mempoolremoved %s\n", txid.GetHex());
+
+    unsigned char value[sizeof(reason)];
+    std::memcpy(value, &reason, sizeof(value));
+
+    std::vector<zmq_message_part> payload = {};
+    payload.push_back(hashToZMQMessagePart(txid));
+    payload.push_back(transactionToZMQMessagePart(transaction));
+    payload.push_back(zmq_message_part(value, value + sizeof(value)));
+
+    return SendZmqMessage(MSG_MEMPOOLREMOVED, payload);
+}
+
+bool CZMQPublishMempoolReplacedNotifier::NotifyTransactionReplaced(const CTransaction &tx_replaced, const CAmount fee_replaced, const CTransaction &tx_replacement, const CAmount fee_replacement)
+{
+    uint256 hash_replaced = tx_replaced.GetHash();
+    uint256 hash_replacement = tx_replacement.GetHash();
+    LogPrint(BCLog::ZMQ, "zmq: Publish mempoolreplaced %s by %s\n", hash_replaced.GetHex(), hash_replacement.GetHex());
+
+    std::vector<zmq_message_part> payload = {};
+    payload.push_back(hashToZMQMessagePart(hash_replaced));
+    payload.push_back(transactionToZMQMessagePart(tx_replaced));
+    payload.push_back(int64ToZMQMessagePart(fee_replaced));
+    payload.push_back(hashToZMQMessagePart(hash_replacement));
+    payload.push_back(transactionToZMQMessagePart(tx_replacement));
+    payload.push_back(int64ToZMQMessagePart(fee_replacement));
+
+    return SendZmqMessage(MSG_MEMPOOLREPLACED, payload);
+}
+
+bool CZMQPublishMempoolConfirmedNotifier::NotifyMempoolTransactionConfirmed(const CTransaction &transaction, const CBlockIndex *pindex)
+{
+    uint256 txid = transaction.GetHash();
+    LogPrint(BCLog::ZMQ, "zmq: Publish mempoolconfirmed %s\n", txid.GetHex());
+
+    std::vector<zmq_message_part> payload = {};
+    payload.push_back(hashToZMQMessagePart(txid));
+    payload.push_back(transactionToZMQMessagePart(transaction));
+    payload.push_back(int32ToZMQMessagePart(pindex->nHeight));
+    payload.push_back(hashToZMQMessagePart(pindex->GetBlockHash()));
+    payload.push_back(headerToZMQMessagePart(pindex->GetBlockHeader()));
+
+    return SendZmqMessage(MSG_MEMPOOLCONFIRMED, payload);
+}
+
+bool CZMQPublishChainTipChangedNotifier::NotifyChainTipChanged(const CBlockIndex *pindex)
+{
+    uint256 hash = pindex->GetBlockHash();
+    LogPrint(BCLog::ZMQ, "zmq: Publish chaintipchanged %s\n", hash.GetHex());
+
+    std::vector<zmq_message_part> payload = {};
+    payload.push_back(hashToZMQMessagePart(hash));
+    payload.push_back(int32ToZMQMessagePart(pindex->nHeight));
+    payload.push_back(headerToZMQMessagePart(pindex->GetBlockHeader()));
+
+    return SendZmqMessage(MSG_CHAINTIPCHANGED, payload);
+}
+
+bool CZMQPublishChainConnectedNotifier::NotifyChainBlockConnected(const CBlockIndex *pindex)
+{
+    uint256 hash = pindex->GetBlockHash();
+    LogPrint(BCLog::ZMQ, "zmq: Publish chainconnected %s\n", hash.GetHex());
+
+    const Consensus::Params& consensusParams = Params().GetConsensus();
+    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());
+    {
+        LOCK(cs_main);
+        CBlock block;
+        if(!ReadBlockFromDisk(block, pindex, consensusParams))
+        {
+            zmqError("Can't read block from disk");
+            return false;
+        }
+        ss << block;
+    }
+
+    std::vector<zmq_message_part> payload = {};
+    payload.push_back(hashToZMQMessagePart(hash));
+    payload.push_back(int32ToZMQMessagePart(pindex->nHeight));
+    payload.push_back(hashToZMQMessagePart(pindex->GetBlockHeader().hashPrevBlock));
+    payload.push_back(zmq_message_part(ss.begin(), ss.end()));
+
+    return SendZmqMessage(MSG_CHAINCONNECTED, payload);
+}
+
+bool CZMQPublishChainHeaderAddedNotifier::NotifyChainHeaderAdded(const CBlockIndex *pindex)
+{
+    uint256 hash = pindex->GetBlockHash();
+    LogPrint(BCLog::ZMQ, "zmq: Publish chainheaderadded %s\n", hash.GetHex());
+
+    std::vector<zmq_message_part> payload = {};
+    payload.push_back(hashToZMQMessagePart(hash));
+    payload.push_back(int32ToZMQMessagePart(pindex->nHeight));
+    payload.push_back(headerToZMQMessagePart(pindex->GetBlockHeader()));
+
+    return SendZmqMessage(MSG_CHAINHEADERADDED, payload);
+}
+
diff --git a/src/zmq/zmqpublishnotifier.h b/src/zmq/zmqpublishnotifier.h
index c1d66bddb..4276c5425 100644
--- a/src/zmq/zmqpublishnotifier.h
+++ b/src/zmq/zmqpublishnotifier.h
@@ -7,8 +7,13 @@
 
 #include <zmq/zmqabstractnotifier.h>
 
+#include <vector>
+
 class CBlockIndex;
 
+typedef std::vector<unsigned char> zmq_message_part;
+typedef std::vector<zmq_message_part> zmq_message;
+
 class CZMQAbstractPublishNotifier : public CZMQAbstractNotifier
 {
 private:
@@ -24,6 +29,14 @@ public:
     */
     bool SendZmqMessage(const char *command, const void* data, size_t size);
 
+    /* sends a zmq multipart message with the following parts:
+        * command (aka ZMQ topic)
+        * timestamp
+        * payload (zero, one or multiple payload parts)
+        * message sequence number
+    */
+    bool SendZmqMessage(const char *command, const std::vector<zmq_message_part>& payload);
+
     bool Initialize(void *pcontext) override;
     void Shutdown() override;
 };
@@ -52,6 +65,48 @@ public:
     bool NotifyTransaction(const CTransaction &transaction) override;
 };
 
+class CZMQPublishMempolAddedNotifier : public CZMQAbstractPublishNotifier
+{
+public:
+    bool NotifyTransactionFee(const CTransaction &transaction, const CAmount fee) override;
+};
+
+class CZMQPublishMempoolRemovedNotifier : public CZMQAbstractPublishNotifier
+{
+public:
+    bool NotifyTransactionRemovalReason(const CTransaction &transaction, const MemPoolRemovalReason reason) override;
+};
+
+class CZMQPublishMempoolReplacedNotifier : public CZMQAbstractPublishNotifier
+{
+public:
+    bool NotifyTransactionReplaced(const CTransaction &tx_replaced, const CAmount fee_replaced, const CTransaction &tx_replacement, const CAmount fee_replacement) override;
+};
+
+class CZMQPublishMempoolConfirmedNotifier : public CZMQAbstractPublishNotifier
+{
+public:
+    bool NotifyMempoolTransactionConfirmed(const CTransaction &transaction, const CBlockIndex *pindex) override;
+};
+
+class CZMQPublishChainTipChangedNotifier : public CZMQAbstractPublishNotifier
+{
+public:
+    bool NotifyChainTipChanged(const CBlockIndex *pindex) override;
+};
+
+class CZMQPublishChainConnectedNotifier : public CZMQAbstractPublishNotifier
+{
+public:
+    bool NotifyChainBlockConnected(const CBlockIndex *index) override;
+};
+
+class CZMQPublishChainHeaderAddedNotifier : public CZMQAbstractPublishNotifier
+{
+public:
+    bool NotifyChainHeaderAdded(const CBlockIndex *pindexHeader) override;
+};
+
 class CZMQPublishSequenceNotifier : public CZMQAbstractPublishNotifier
 {
 public:
diff --git a/test/functional/interface_zmq.py b/test/functional/interface_zmq.py
index 15f352d68..395a1bc96 100755
--- a/test/functional/interface_zmq.py
+++ b/test/functional/interface_zmq.py
@@ -234,10 +234,10 @@ class ZMQTest (BitcoinTestFramework):
 
         self.log.info("Test the getzmqnotifications RPC")
         assert_equal(self.nodes[0].getzmqnotifications(), [
-            {"type": "pubhashblock", "address": address, "hwm": 1000},
-            {"type": "pubhashtx", "address": address, "hwm": 1000},
-            {"type": "pubrawblock", "address": address, "hwm": 1000},
-            {"type": "pubrawtx", "address": address, "hwm": 1000},
+            {"type": "pubhashblock", "address": address, "hwm": 100000},
+            {"type": "pubhashtx", "address": address, "hwm": 100000},
+            {"type": "pubrawblock", "address": address, "hwm": 100000},
+            {"type": "pubrawtx", "address": address, "hwm": 100000},
         ])
 
         assert_equal(self.nodes[1].getzmqnotifications(), [])
diff --git a/test/functional/interface_zmq_chainblockconnected.py b/test/functional/interface_zmq_chainblockconnected.py
new file mode 100644
index 000000000..f631766f4
--- /dev/null
+++ b/test/functional/interface_zmq_chainblockconnected.py
@@ -0,0 +1,121 @@
+#!/usr/bin/env python3
+# Copyright (c) 2015-2019 The Bitcoin Core developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""Test the ZMQ publisher chainconnected to notify about blocks being
+connected to the chain (blocktree)"""
+import struct
+import zmq
+
+from test_framework.address import ADDRESS_BCRT1_UNSPENDABLE
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.messages import CTransaction, hash256
+from test_framework.util import assert_equal
+from io import BytesIO
+from time import sleep
+from random import randint
+
+from test_framework.util_patched_zmq import ZMQSubscriber
+
+
+def hash256_reversed(byte_str):
+    return hash256(byte_str)[::-1]
+
+
+class ZMQTest (BitcoinTestFramework):
+    def set_test_params(self):
+        self.num_nodes = 2
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_py3_zmq()
+        self.skip_if_no_bitcoind_zmq()
+
+    def run_test(self):
+        import zmq
+        self.ctx = zmq.Context()
+        try:
+            self.test_basic()
+            self.test_reorg()
+        finally:
+            # Destroy the ZMQ context.
+            self.log.debug("Destroying ZMQ context")
+            self.ctx.destroy(linger=None)
+
+    def test_basic(self):
+        address = 'tcp://127.0.0.1:{}'.format(randint(20000, 50000))
+        socket = self.ctx.socket(zmq.SUB)
+        socket.set(zmq.RCVTIMEO, 60000)
+        subscriber = ZMQSubscriber(socket, b'chainconnected')
+
+        self.log.info("Test patched chainconnected topic")
+        self.restart_node(0, ['-zmqpub%s=%s' %
+                          (subscriber.topic.decode(), address)])
+        socket.connect(address)
+        # Relax so that the subscriber is ready before publishing zmq messages
+        sleep(0.2)
+        self.connect_nodes(0, 1)
+
+        lastHeight = self.nodes[0].getblockcount()
+        lastHash = self.nodes[0].getblockhash(lastHeight)
+
+        self.log.info(
+            "Generate 3 block in nodes[0] and receive all notifications")
+        genhashes_node0 = self.nodes[0].generatetoaddress(
+            3, ADDRESS_BCRT1_UNSPENDABLE)
+        for block_hash in genhashes_node0:
+            hash, height, prevhash, block = subscriber.receive_multi_payload()
+            assert_equal(struct.unpack("<I", height)[0], lastHeight+1)
+            assert_equal(lastHash, prevhash.hex())
+            assert_equal(block_hash, hash.hex())
+            assert_equal(block_hash, hash256_reversed(block[:80]).hex())
+            # update last height and hash
+            lastHeight += 1
+            lastHash = block_hash
+
+        # allow both nodes to sync
+        sleep(1)
+        self.disconnect_nodes(0, 1)
+
+    def test_reorg(self):
+        address = 'tcp://127.0.0.1:{}'.format(randint(20000, 50000))
+        socket = self.ctx.socket(zmq.SUB)
+        socket.set(zmq.RCVTIMEO, 60000)
+        subscriber = ZMQSubscriber(socket, b'chainconnected')
+
+        self.log.info("Reorg testing ZMQ publisher chainconnected")
+
+        # chainconnected should notify for every block connected
+        self.restart_node(0, ['-zmqpub%s=%s' %
+                          (subscriber.topic.decode(), address)])
+        socket.connect(address)
+        # Relax so that the subscriber is ready before publishing zmq messages
+        sleep(0.2)
+
+        preForkHeight = self.nodes[0].getblockcount()
+        preForkHash = self.nodes[0].getblockhash(preForkHeight)
+
+        self.log.info("Generate ten blocks in node 0")
+        self.nodes[0].generatetoaddress(10, ADDRESS_BCRT1_UNSPENDABLE)
+
+        self.log.info("Generate six blocks in node 1")
+        genhashes_node1 = self.nodes[1].generatetoaddress(
+            6, ADDRESS_BCRT1_UNSPENDABLE)
+
+        self.log.info("Reconect both nodes")
+        self.connect_nodes(0, 1)
+
+        self.log.info(
+            "Node 0 should connect all six blocks generate by node 1, even if node 0 has a longer chain.")
+        for block_hash in genhashes_node1:
+            hash, height, prevhash, block = subscriber.receive_multi_payload()
+            assert_equal(struct.unpack("<I", height)[0], preForkHeight+1)
+            assert_equal(preForkHash, prevhash.hex())
+            assert_equal(block_hash, hash.hex())
+            assert_equal(block_hash, hash256_reversed(block[:80]).hex())
+            # update last height and hash
+            preForkHeight += 1
+            preForkHash = block_hash
+
+
+if __name__ == '__main__':
+    ZMQTest().main()
diff --git a/test/functional/interface_zmq_chainheaderadded.py b/test/functional/interface_zmq_chainheaderadded.py
new file mode 100644
index 000000000..c1fa4f6a1
--- /dev/null
+++ b/test/functional/interface_zmq_chainheaderadded.py
@@ -0,0 +1,124 @@
+#!/usr/bin/env python3
+# Copyright (c) 2015-2019 The Bitcoin Core developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""Test the ZMQ publisher chainheaderadded to notify about headers being
+added to the chain (headertree)"""
+import struct
+import zmq
+
+from test_framework.address import ADDRESS_BCRT1_UNSPENDABLE, ADDRESS_BCRT1_P2WSH_OP_TRUE
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.messages import CTransaction, hash256
+from test_framework.util import assert_equal
+from io import BytesIO
+from time import sleep
+from random import randint
+
+from test_framework.util_patched_zmq import ZMQSubscriber
+
+TOPIC = b'chainheaderadded'
+
+
+def hash256_reversed(byte_str):
+    return hash256(byte_str)[::-1]
+
+
+class ZMQTest (BitcoinTestFramework):
+    def set_test_params(self):
+        self.num_nodes = 2
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_py3_zmq()
+        self.skip_if_no_bitcoind_zmq()
+
+    def run_test(self):
+        import zmq
+        self.ctx = zmq.Context()
+        try:
+            self.test_basic()
+            self.test_reorg()
+        finally:
+            # Destroy the ZMQ context.
+            self.log.debug("Destroying ZMQ context")
+            self.ctx.destroy(linger=None)
+
+    def test_basic(self):
+        address = 'tcp://127.0.0.1:{}'.format(randint(20000, 50000))
+        socket = self.ctx.socket(zmq.SUB)
+        socket.set(zmq.RCVTIMEO, 2000)
+        subscriber = ZMQSubscriber(socket, TOPIC)
+
+        self.log.info("Test patched chainheaderadded topic")
+
+        # chainheaderadded should notify for every block header added
+        self.restart_node(0, ['-zmqpub%s=%s' %
+                          (subscriber.topic.decode(), address)])
+        socket.connect(address)
+        # Relax so that the subscriber is ready before publishing zmq messages
+        sleep(0.2)
+
+        lastHeight = self.nodes[0].getblockcount()
+
+        self.log.info("Generate 3 blocks in node 0 and receive notifications")
+        genhashes_node0 = self.nodes[0].generatetoaddress(
+            3, ADDRESS_BCRT1_UNSPENDABLE)
+        for block_hash in genhashes_node0:
+            hash, height, header = subscriber.receive_multi_payload()
+            assert_equal(lastHeight+1, struct.unpack("<I", height)[0])
+            assert_equal(block_hash, hash.hex())
+            assert_equal(self.nodes[0].getblockheader(
+                hash.hex(), False), header.hex())
+            lastHeight += 1
+
+        # allow both nodes to sync
+        self.connect_nodes(0, 1)
+        sleep(1)
+        self.disconnect_nodes(0, 1)
+
+    def test_reorg(self):
+        address = 'tcp://127.0.0.1:{}'.format(randint(20000, 50000))
+        socket = self.ctx.socket(zmq.SUB)
+        socket.set(zmq.RCVTIMEO, 2000)
+        subscriber = ZMQSubscriber(socket, TOPIC)
+
+        self.log.info("Reorg testing ZMQ publisher chainheaderadded")
+
+        # chainheaderadded should notify for every block header added
+        self.restart_node(0, ['-zmqpub%s=%s' %
+                          (subscriber.topic.decode(), address)])
+        socket.connect(address)
+        # Relax so that the subscriber is ready before publishing zmq messages
+        sleep(0.2)
+
+        self.log.info("Disconnect nodes 0 and 1")
+        self.disconnect_nodes(0, 1)
+
+        preForkHeight = self.nodes[0].getblockcount()
+
+        self.log.info("Generate 6 blocks in node 0")
+        genhashes_node0 = self.nodes[0].generatetoaddress(
+            6, ADDRESS_BCRT1_UNSPENDABLE)
+        for _ in genhashes_node0:
+            _ = subscriber.receive_multi_payload()
+
+        self.log.info("Generate 3 different blocks in node 1")
+        genhashes_node1 = self.nodes[1].generatetoaddress(
+            3, ADDRESS_BCRT1_P2WSH_OP_TRUE)
+
+        self.log.info("Connect node 0 and node 1")
+        self.connect_nodes(0, 1)
+
+        self.log.info(
+            "Receive notifications about headers in node 0 even if it has a longer chain")
+        for block_hash in genhashes_node1:
+            hash, height, header = subscriber.receive_multi_payload()
+            assert_equal(preForkHeight+1, struct.unpack("<I", height)[0])
+            assert_equal(block_hash, hash.hex())
+            assert_equal(self.nodes[0].getblockheader(
+                hash.hex(), False), header.hex())
+            preForkHeight += 1
+
+
+if __name__ == '__main__':
+    ZMQTest().main()
diff --git a/test/functional/interface_zmq_chaintipchanged.py b/test/functional/interface_zmq_chaintipchanged.py
new file mode 100644
index 000000000..7f0e5689c
--- /dev/null
+++ b/test/functional/interface_zmq_chaintipchanged.py
@@ -0,0 +1,116 @@
+#!/usr/bin/env python3
+# Copyright (c) 2015-2019 The Bitcoin Core developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""Test the ZMQ publisher chaintipchanged to notify about a changed
+chain tip"""
+import struct
+import zmq
+
+from test_framework.address import ADDRESS_BCRT1_UNSPENDABLE
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.messages import CTransaction, hash256
+from test_framework.util import assert_equal
+from io import BytesIO
+from time import sleep
+from random import randint
+
+from test_framework.util_patched_zmq import ZMQSubscriber
+
+
+def hash256_reversed(byte_str):
+    return hash256(byte_str)[::-1]
+
+
+class ZMQTest (BitcoinTestFramework):
+    def set_test_params(self):
+        self.num_nodes = 2
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_py3_zmq()
+        self.skip_if_no_bitcoind_zmq()
+
+    def run_test(self):
+        import zmq
+        self.ctx = zmq.Context()
+        try:
+            self.test_basic()
+            self.test_reorg()
+        finally:
+            # Destroy the ZMQ context.
+            self.log.debug("Destroying ZMQ context")
+            self.ctx.destroy(linger=None)
+
+    def test_basic(self):
+        address = 'tcp://127.0.0.1:{}'.format(randint(20000, 50000))
+        socket = self.ctx.socket(zmq.SUB)
+        socket.set(zmq.RCVTIMEO, 60000)
+        subscriber = ZMQSubscriber(socket, b'chaintipchanged')
+
+        self.log.info("Test patched chaintipchanged topic")
+
+        self.restart_node(0, ['-zmqpub%s=%s' %
+                          (subscriber.topic.decode(), address)])
+        socket.connect(address)
+        # Relax so that the subscriber is ready before publishing zmq messages
+        sleep(0.2)
+
+        lastHeight = self.nodes[0].getblockcount()
+        lastHash = self.nodes[0].getblockhash(lastHeight)
+
+        self.log.info(
+            "Generate 3 block in nodes[0] and receive all notifications")
+        genhashes_node0 = self.nodes[0].generatetoaddress(
+            3, ADDRESS_BCRT1_UNSPENDABLE)
+        for block_hash in genhashes_node0:
+            hash, height, header = subscriber.receive_multi_payload()
+            assert_equal(struct.unpack("<I", height)[0], lastHeight+1)
+            assert_equal(block_hash, hash.hex())
+            assert_equal(self.nodes[0].getblockheader(
+                hash.hex(), False), header.hex())
+            # update last height and hash
+            lastHeight += 1
+            lastHash = block_hash
+
+        # allow both nodes to sync
+        self.connect_nodes(0, 1)
+        self.sync_all()
+        self.disconnect_nodes(0, 1)
+
+    def test_reorg(self):
+        address = 'tcp://127.0.0.1:{}'.format(randint(20000, 50000))
+        socket = self.ctx.socket(zmq.SUB)
+        socket.set(zmq.RCVTIMEO, 1000)
+        subscriber = ZMQSubscriber(socket, b'chaintipchanged')
+
+        self.log.info("Reorg testing ZMQ publisher chaintipchanged")
+        self.restart_node(0, ['-zmqpub%s=%s' %
+                          (subscriber.topic.decode(), address)])
+        socket.connect(address)
+        # Relax so that the subscriber is ready before publishing zmq messages
+        sleep(0.2)
+
+        self.disconnect_nodes(0, 1)
+
+        self.log.info("Generate ten blocks in node 0")
+        genhashes_node0 = self.nodes[0].generatetoaddress(
+            10, ADDRESS_BCRT1_UNSPENDABLE)
+        for _ in genhashes_node0:
+            subscriber.receive_multi_payload()
+
+        self.log.info("Generate six blocks in node 1")
+        self.nodes[1].generatetoaddress(6, ADDRESS_BCRT1_UNSPENDABLE)
+
+        self.log.info("Connect both nodes")
+        self.connect_nodes(0, 1)
+
+        self.log.info(
+            "Node 0 should not change the tip for a block generated by node 1 as node 0 has a longer chain")
+        try:
+            subscriber.receive_multi_payload()
+        except zmq.error.Again as e:
+            self.log.info("ZMQ subscriber timed out as expected: {}".format(e))
+
+
+if __name__ == '__main__':
+    ZMQTest().main()
diff --git a/test/functional/interface_zmq_mempooladded.py b/test/functional/interface_zmq_mempooladded.py
new file mode 100644
index 000000000..4e0b50cf7
--- /dev/null
+++ b/test/functional/interface_zmq_mempooladded.py
@@ -0,0 +1,82 @@
+#!/usr/bin/env python3
+# Copyright (c) 2015-2020 The Bitcoin Core developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""Test the ZMQ publisher 'mempooladded' to notify about transactions and their
+fee when being added to the mempool."""
+
+import zmq
+import struct
+from time import sleep
+from random import randint
+
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.messages import CTransaction, COIN
+from test_framework.util import assert_equal
+from io import BytesIO
+from test_framework.util_patched_zmq import ZMQSubscriber
+
+
+class ZMQTest (BitcoinTestFramework):
+    def set_test_params(self):
+        self.num_nodes = 1
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_py3_zmq()
+        self.skip_if_no_bitcoind_zmq()
+        self.skip_if_no_wallet()
+
+    def run_test(self):
+        self.ctx = zmq.Context()
+        try:
+            self.test_mempool_added()
+        finally:
+            # Destroy the ZMQ context.
+            self.log.debug("Destroying ZMQ context")
+            self.ctx.destroy(linger=None)
+
+    def test_mempool_added(self):
+        address = 'tcp://127.0.0.1:{}'.format(randint(20000, 50000))
+        socket = self.ctx.socket(zmq.SUB)
+        socket.set(zmq.RCVTIMEO, 60000)
+
+        self.log.info("Testing ZMQ publisher mempooladded")
+        subscriber = ZMQSubscriber(socket, b"mempooladded")
+
+        self.restart_node(
+            0, ["-zmqpub{}={}".format(subscriber.topic.decode(), address)])
+        socket.connect(address)
+        # Relax so that the subscriber is ready before publishing zmq messages
+        sleep(0.2)
+
+        node = self.nodes[0]
+        txid = node.sendtoaddress(node.getnewaddress(), 1.0)
+        self.sync_all()
+
+        self.log.info(
+            "Should receive a payload with three elements (txid rawtx, fee)")
+        payload = subscriber.receive_multi_payload()
+        assert_equal(3, len(payload))
+
+        self.log.info("First payload element should be the txid")
+        r_txid = payload[0]
+        assert_equal(txid, r_txid.hex())
+
+        self.log.info("Second payload element should be the raw transaction")
+        r_rawtx = payload[1]
+        tx = CTransaction()
+        tx.deserialize(BytesIO(r_rawtx))
+        tx.calc_sha256()
+        assert_equal(txid, tx.hash)
+
+        self.log.info("Third payload element should be the transaction fee")
+        r_fee = struct.unpack('<q', payload[2])[-1]
+        assert_equal(int(node.getmempoolentry(txid)["fee"] * COIN), r_fee)
+
+        self.log.info("Test the getzmqnotifications RPC for mempooladded")
+        assert_equal(node.getzmqnotifications(), [
+                     {"type": "pubmempooladded", "address": address, "hwm": 100000}])
+
+
+if __name__ == '__main__':
+    ZMQTest().main()
diff --git a/test/functional/interface_zmq_mempoolconfirmed.py b/test/functional/interface_zmq_mempoolconfirmed.py
new file mode 100644
index 000000000..9c0076863
--- /dev/null
+++ b/test/functional/interface_zmq_mempoolconfirmed.py
@@ -0,0 +1,69 @@
+#!/usr/bin/env python3
+# Copyright (c) 2015-2019 The Bitcoin Core developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""Test the ZMQ publisher mempoolconfirmed to notify about transactions that
+were included in a block and thus removed from the mempool"""
+
+from random import randint
+from time import sleep, time
+import struct
+import zmq
+
+from test_framework.test_framework import BitcoinTestFramework, assert_equal
+from test_framework.util_patched_zmq import ZMQSubscriber, removalReason
+
+
+class ZMQTest (BitcoinTestFramework):
+    def set_test_params(self):
+        self.num_nodes = 1
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_py3_zmq()
+        self.skip_if_no_bitcoind_zmq()
+        self.skip_if_no_wallet()
+
+    def run_test(self):
+        import zmq
+        self.ctx = zmq.Context()
+        try:
+            self.test_mempool_removed()
+        finally:
+            # Destroy the ZMQ context.
+            self.log.debug("Destroying ZMQ context")
+            self.ctx.destroy(linger=None)
+
+    def test_mempool_removed(self):
+        address = 'tcp://127.0.0.1:{}'.format(randint(20000, 22222))
+        socket = self.ctx.socket(zmq.SUB)
+        socket.set(zmq.RCVTIMEO, 60000)
+        topic = b'mempoolconfirmed'
+
+        arg_zmq_mempoolconfirmed = "-zmqpub%s=%s" % (
+            topic.decode(), address)
+
+        node0 = self.nodes[0]
+
+        subscriber = ZMQSubscriber(socket, topic)
+        self.restart_node(0, [arg_zmq_mempoolconfirmed, "-txindex"])
+        sleep(0.2)
+        socket.connect(address)
+
+        self.log.info("Testing mempoolconfirmed")
+        txid = node0.sendtoaddress(node0.getnewaddress(), 1.0)
+        hash = node0.generatetoaddress(1, node0.getnewaddress())
+
+        raw = node0.getrawtransaction(txid)
+        height = node0.getblockcount()
+
+        r_txid, r_raw, r_height, r_hash, header = subscriber.receive_multi_payload()
+        assert_equal(txid, r_txid.hex())
+        assert_equal(raw, r_raw.hex())
+        assert_equal(height, struct.unpack("<I", r_height)[0])
+        assert_equal(hash[0], r_hash.hex())
+        assert_equal(self.nodes[0].getblockheader(
+            r_hash.hex(), False), header.hex())
+
+
+if __name__ == '__main__':
+    ZMQTest().main()
diff --git a/test/functional/interface_zmq_mempoolremove_block.py b/test/functional/interface_zmq_mempoolremove_block.py
new file mode 100644
index 000000000..90a45bcac
--- /dev/null
+++ b/test/functional/interface_zmq_mempoolremove_block.py
@@ -0,0 +1,61 @@
+#!/usr/bin/env python3
+# Copyright (c) 2015-2022 The Bitcoin Core developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""Test the ZMQ publisher mempoolremoved to notify about transactions that
+were removed from the mempool by block inclusion"""
+
+from random import randint
+from time import sleep, time
+
+import zmq
+
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util_patched_zmq import ZMQSubscriber, removalReason
+
+
+class ZMQTest (BitcoinTestFramework):
+    def set_test_params(self):
+        self.num_nodes = 1
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_py3_zmq()
+        self.skip_if_no_bitcoind_zmq()
+        self.skip_if_no_wallet()
+
+    def run_test(self):
+        import zmq
+        self.ctx = zmq.Context()
+        try:
+            self.test_mempool_removed()
+        finally:
+            # Destroy the ZMQ context.
+            self.log.debug("Destroying ZMQ context")
+            self.ctx.destroy(linger=None)
+
+    def test_mempool_removed(self):
+        address = 'tcp://127.0.0.1:{}'.format(randint(20000, 22222))
+        socket = self.ctx.socket(zmq.SUB)
+        socket.set(zmq.RCVTIMEO, 60000)
+        topic = b'mempoolremoved'
+
+        arg_zmq_mempoolremoved = "-zmqpub%s=%s" % (
+            topic.decode(), address)
+
+        node0 = self.nodes[0]
+
+        subscriber = ZMQSubscriber(socket, topic)
+        self.restart_node(0, [arg_zmq_mempoolremoved])
+        sleep(0.2)
+        socket.connect(address)
+
+        self.log.info("Testing mempoolremoved BLOCK")
+        txid = node0.sendtoaddress(node0.getnewaddress(), 1.0)
+        node0.generatetoaddress(1, node0.getnewaddress())
+
+        expected = {txid: 'BLOCK'}
+        subscriber.check_mempoolremoved_messages(expected)
+
+
+if __name__ == '__main__':
+    ZMQTest().main()
diff --git a/test/functional/interface_zmq_mempoolremove_conflict.py b/test/functional/interface_zmq_mempoolremove_conflict.py
new file mode 100644
index 000000000..98aa8d447
--- /dev/null
+++ b/test/functional/interface_zmq_mempoolremove_conflict.py
@@ -0,0 +1,116 @@
+#!/usr/bin/env python3
+# Copyright (c) 2015-2022 The Bitcoin Core developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""Test the ZMQ publisher mempoolremoved to notify about transactions that
+were removed from the mempool due to conflicting with an in-block
+transaction"""
+
+import zmq
+from time import sleep
+from random import randint
+
+from test_framework.address import ADDRESS_BCRT1_UNSPENDABLE
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import assert_equal, find_vout_for_address
+from test_framework.util_patched_zmq import ZMQSubscriber, removalReason
+
+
+class ZMQTest (BitcoinTestFramework):
+    def set_test_params(self):
+        self.num_nodes = 2
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_py3_zmq()
+        self.skip_if_no_bitcoind_zmq()
+        self.skip_if_no_wallet()
+
+    def run_test(self):
+        import zmq
+        self.ctx = zmq.Context()
+        try:
+            self.test_mempool_removed()
+        finally:
+            # Destroy the ZMQ context.
+            self.log.debug("Destroying ZMQ context")
+            self.ctx.destroy(linger=None)
+
+    def receive_removed_transaction(self, zmq_subscriber):
+        # Should receive a payload with two elements (rawtx, removal reason)
+        payload = zmq_subscriber.receive_multi_payload()
+        assert_equal(2, len(payload))
+
+        # First payload element should be the raw transaction
+        rawtx = payload[0]
+        tx = CTransaction()
+        tx.deserialize(BytesIO(rawtx))
+        tx.calc_sha256()
+
+        # Second payload element should be the removal reason
+        reason = struct.unpack('<I', payload[1])[-1]
+
+        return [tx.hash, reason]
+
+    def test_mempool_removed(self):
+        address = 'tcp://127.0.0.1:{}'.format(randint(20000, 50000))
+        socket = self.ctx.socket(zmq.SUB)
+        socket.set(zmq.RCVTIMEO, 60000)
+        topic = b"mempoolremoved"
+
+        arg_zmq_mempoolremoved = "-zmqpub%s=%s" % (topic.decode(), address)
+        arg_txindex = "-txindex=1"
+
+        node0 = self.nodes[0]
+        node1 = self.nodes[1]
+
+        subscriber = ZMQSubscriber(socket, topic)
+        self.restart_node(0, [arg_txindex, arg_zmq_mempoolremoved])
+        sleep(0.2)
+        socket.connect(address)
+
+        self.log.info("Testing mempoolremoved CONFLICT")
+        self.connect_nodes(0, 1)
+        self.sync_all()
+
+        self.log.info(
+            "create an utxo that the in-block and the in-mempool transaction will spend")
+        utxo_address = node0.getnewaddress()
+        utxo_txid = node0.sendtoaddress(utxo_address, 1.0)
+        node0.generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)
+        # discard zmq messages for removed tx for block inclusion
+        subscriber.discard_mempoolremoved_message_block()
+
+        self.log.info(
+            "reate two different transactions spending the same UTXO")
+        txns = []
+        vout = find_vout_for_address(node0, utxo_txid, utxo_address)
+        inputs = [{'txid': utxo_txid, 'vout': vout}]
+        for _ in range(2):
+            outputs = {node0.getnewaddress(): 0.99}
+            raw = node0.createrawtransaction(inputs, outputs)
+            signed = node0.signrawtransactionwithwallet(raw)["hex"]
+            txns.append(signed)
+
+        self.log.info("disconnect the nodes")
+        self.sync_all()
+        self.disconnect_nodes(0, 1)
+        self.log.info("Nodes disconnected")
+
+        self.log.info("node1: broadcast the first tx and then mine a block on")
+        node1.sendrawtransaction(txns[0])
+        node1.generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)[0]
+
+        self.log.info("node0: broadcast the in-mempool tx")
+        inmempool_txid = node0.sendrawtransaction(txns[1])
+
+        self.log.info("re-connect the nodes")
+        self.connect_nodes(0, 1)
+
+        self.log.info(
+            "The ZMQ interface should receive the in-mempool tx that conflicts with the in-block transaction")
+        expected = {inmempool_txid: 'CONFLICT'}
+        subscriber.check_mempoolremoved_messages(expected)
+
+
+if __name__ == '__main__':
+    ZMQTest().main()
diff --git a/test/functional/interface_zmq_mempoolremove_expiry.py b/test/functional/interface_zmq_mempoolremove_expiry.py
new file mode 100644
index 000000000..e4eb84c2f
--- /dev/null
+++ b/test/functional/interface_zmq_mempoolremove_expiry.py
@@ -0,0 +1,112 @@
+#!/usr/bin/env python3
+# Copyright (c) 2015-2022 The Bitcoin Core developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""Test the ZMQ publisher mempoolremoved to notify about transactions that
+expired from the mempool"""
+
+from random import randint
+from time import sleep, time
+
+import zmq
+
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import assert_equal, find_vout_for_address
+from test_framework.util_patched_zmq import ZMQSubscriber, removalReason
+
+
+class ZMQTest (BitcoinTestFramework):
+    def set_test_params(self):
+        self.num_nodes = 1
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_py3_zmq()
+        self.skip_if_no_bitcoind_zmq()
+        self.skip_if_no_wallet()
+
+    def run_test(self):
+        import zmq
+        self.ctx = zmq.Context()
+        try:
+            self.test_mempool_removed()
+        finally:
+            # Destroy the ZMQ context.
+            self.log.debug("Destroying ZMQ context")
+            self.ctx.destroy(linger=None)
+
+    def test_mempool_removed(self):
+        address = 'tcp://127.0.0.1:{}'.format(randint(20000, 50000))
+        socket = self.ctx.socket(zmq.SUB)
+        socket.set(zmq.RCVTIMEO, 60000)
+        topic = b"mempoolremoved"
+
+        arg_zmq_mempoolremoved = "-zmqpub%s=%s" % (
+            topic.decode(), address)
+
+        node = self.nodes[0]
+
+        self.log.info("Testing ZMQ publisher mempoolremoved")
+        subscriber = ZMQSubscriber(socket, topic)
+        self.restart_node(0, [arg_zmq_mempoolremoved])
+        # Relax so that the subscriber is ready before publishing zmq messages
+        sleep(0.2)
+        socket.connect(address)
+
+        self.log.info(
+            "Testing the getzmqnotifications RPC for mempoolremoved")
+        assert_equal(node.getzmqnotifications(), [
+            {"type": "pubmempoolremoved", "address": address, "hwm": 100000}])
+
+        self.log.info("Testing removal reason EXPIRY")
+        DEFAULT_MEMPOOL_EXPIRY = 336
+
+        self.log.info("Send a parent transaction that will expire.")
+        parent_address = node.getnewaddress()
+        parent_txid = node.sendtoaddress(parent_address, 1.0)
+
+        self.log.info(
+            "Set the mocktime to the arrival time of the parent transaction.")
+        entry_time = node.getmempoolentry(parent_txid)["time"]
+        node.setmocktime(entry_time)
+
+        self.log.info(
+            "Create child transaction spending the parent transaction")
+        vout = find_vout_for_address(node, parent_txid, parent_address)
+        inputs = [{'txid': parent_txid, 'vout': vout}]
+        outputs = {node.getnewaddress(): 0.99}
+        child_raw = node.createrawtransaction(inputs, outputs)
+        child_signed = node.signrawtransactionwithwallet(child_raw)["hex"]
+
+        self.log.info(
+            "Let half of the timeout elapse and broadcast the child transaction.")
+        half_expiry_time = entry_time + \
+            int(60 * 60 * DEFAULT_MEMPOOL_EXPIRY/2)
+        node.setmocktime(half_expiry_time)
+        child_txid = node.sendrawtransaction(child_signed)
+
+        self.log.info(
+            "Let most of the timeout elapse and check that the parent tx is still in the mempool.")
+        nearly_expiry_time = entry_time + 60 * 60 * DEFAULT_MEMPOOL_EXPIRY - 5
+        node.setmocktime(nearly_expiry_time)
+        # Expiry of mempool transactions is only checked when a new transaction
+        # is added to the to the mempool.
+        node.sendtoaddress(node.getnewaddress(), 1.0)
+        assert_equal(entry_time, node.getmempoolentry(parent_txid)["time"])
+
+        self.log.info(
+            "Transaction should be evicted from the mempool after the expiry time has passed.")
+        expiry_time = entry_time + 60 * 60 * DEFAULT_MEMPOOL_EXPIRY + 5
+        node.setmocktime(expiry_time)
+        # Expiry of mempool transactions is only checked when a new transaction
+        # is added to the to the mempool.
+        self.log.info("")
+        node.sendtoaddress(node.getnewaddress(), 1.0)
+
+        self.log.info(
+            "The ZMQ interface should receive two removed transactions (the parent and the child), however we don't know the removal order.")
+        expected = {parent_txid: 'EXPIRY', child_txid: 'EXPIRY'}
+        subscriber.check_mempoolremoved_messages(expected)
+
+
+if __name__ == '__main__':
+    ZMQTest().main()
diff --git a/test/functional/interface_zmq_mempoolremove_reorg.py b/test/functional/interface_zmq_mempoolremove_reorg.py
new file mode 100644
index 000000000..3aed101cc
--- /dev/null
+++ b/test/functional/interface_zmq_mempoolremove_reorg.py
@@ -0,0 +1,97 @@
+#!/usr/bin/env python3
+# Copyright (c) 2015-2022 The Bitcoin Core developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""Test the ZMQ publisher mempoolremoved to notify about transactions that
+were removed from the mempool in a reorg"""
+
+
+from random import randint
+from time import sleep
+
+import zmq
+
+from test_framework.address import ADDRESS_BCRT1_UNSPENDABLE
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import assert_equal, find_vout_for_address
+from test_framework.util_patched_zmq import ZMQSubscriber, removalReason
+
+
+class ZMQTest (BitcoinTestFramework):
+    def set_test_params(self):
+        self.num_nodes = 1
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_py3_zmq()
+        self.skip_if_no_bitcoind_zmq()
+        self.skip_if_no_wallet()
+
+    def run_test(self):
+        import zmq
+        self.ctx = zmq.Context()
+        try:
+            self.test_mempool_removed()
+        finally:
+            # Destroy the ZMQ context.
+            self.log.debug("Destroying ZMQ context")
+            self.ctx.destroy(linger=None)
+
+    def test_mempool_removed(self):
+        address = 'tcp://127.0.0.1:{}'.format(randint(20000, 50000))
+        socket = self.ctx.socket(zmq.SUB)
+        socket.set(zmq.RCVTIMEO, 60000)
+        topic = b"mempoolremoved"
+
+        arg_zmq_mempoolremoved = "-zmqpub%s=%s" % (
+            topic.decode(), address)
+        arg_txindex = "-txindex=1"
+
+        node = self.nodes[0]
+
+        self.log.info("Testing ZMQ publisher mempoolremoved REORG")
+        subscriber = ZMQSubscriber(socket, topic)
+        self.restart_node(0, [arg_txindex, arg_zmq_mempoolremoved])
+        sleep(0.2)
+        socket.connect(address)
+
+        # Test that transactions removed from our mempool due to a reorg are notified
+        # There are several other reasons a tx could be removed for REORG:
+        # - a spend from a coinbase output that is no longer mature (>100 confirmations)
+        # - a descendants of non-final and non-mature outputs.
+        # - if the re-org has been deep enough that the disconnect pool has filled up
+        # - if the standardness or consensus rules have changed across the reorg
+        # - and probably more...
+        # We only test the non-final case.
+        self.log.info(
+            "Testing removal reason REORG (tx non-final after reorg)")
+
+        self.log.info("Create an output to spend from")
+        address = node.getnewaddress()
+        included_in_block_txid = node.sendtoaddress(address, 1.0)
+        tip = node.generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)[0]
+        # discard zmq messages for removed tx for block inclusion
+        subscriber.discard_mempoolremoved_message_block()
+
+        self.log.info("spend output from tx from the just mined block")
+        vout = find_vout_for_address(node, included_in_block_txid, address)
+        inputs = [{'txid': included_in_block_txid, 'vout': vout}]
+        outputs = {node.getnewaddress(): 0.99}
+        # set a locktime of the current height
+        locktime = node.getblockcount()
+        raw = node.createrawtransaction(inputs, outputs, locktime)
+        signed = node.signrawtransactionwithwallet(raw)["hex"]
+        mempool_to_be_reorged_txid = node.sendrawtransaction(signed)
+
+        self.log.info("invalidate the just mined block")
+        node.invalidateblock(tip)
+
+        self.log.info("The ZMQ interface should receive the transaction that is reorged as the transaction is not final anymore")
+        expected = {mempool_to_be_reorged_txid: "REORG"}
+        subscriber.check_mempoolremoved_messages(expected)
+
+        self.log.info("The mempool should now contain the 'included_in_block_txid' tx")
+        assert_equal(True, included_in_block_txid in node.getrawmempool())
+
+
+if __name__ == '__main__':
+    ZMQTest().main()
diff --git a/test/functional/interface_zmq_mempoolremove_replaced.py b/test/functional/interface_zmq_mempoolremove_replaced.py
new file mode 100644
index 000000000..8c6af706a
--- /dev/null
+++ b/test/functional/interface_zmq_mempoolremove_replaced.py
@@ -0,0 +1,95 @@
+#!/usr/bin/env python3
+# Copyright (c) 2015-2022 The Bitcoin Core developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""Test the ZMQ publisher mempoolremoved to notify about transactions that
+were replaced."""
+
+
+import struct
+from io import BytesIO
+from time import sleep, time
+from random import randint
+
+from feature_rbf import make_utxo
+from test_framework.address import ADDRESS_BCRT1_UNSPENDABLE
+from test_framework.messages import (
+    COIN,
+    COutPoint,
+    CTransaction,
+    CTxIn,
+    CTxOut
+)
+from test_framework.script import CScript
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import (
+    assert_equal, assert_raises_rpc_error, find_vout_for_address)
+from test_framework.util_patched_zmq import ZMQSubscriber, removalReason
+
+
+class ZMQTest (BitcoinTestFramework):
+    def set_test_params(self):
+        self.num_nodes = 1
+        self.extra_args = [["-acceptnonstdtxn=1"]]
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_py3_zmq()
+        self.skip_if_no_bitcoind_zmq()
+        self.skip_if_no_wallet()
+
+    def run_test(self):
+        import zmq
+        self.ctx = zmq.Context()
+        try:
+            self.test_mempool_removed()
+        finally:
+            # Destroy the ZMQ context.
+            self.log.debug("Destroying ZMQ context")
+            self.ctx.destroy(linger=None)
+
+    def test_mempool_removed(self):
+        import zmq
+        address = 'tcp://127.0.0.1:{}'.format(randint(20000, 50000))
+        socket = self.ctx.socket(zmq.SUB)
+        socket.set(zmq.RCVTIMEO, 60000)
+        topic = b"mempoolremoved"
+
+        arg_zmq_mempoolremoved = "-zmqpub%s=%s" % (topic.decode(), address)
+        arg_accept_non_standard = "-acceptnonstdtxn=1"
+
+        node = self.nodes[0]
+
+        self.log.info(
+            "create an utxo before we start to listen on mempoolremoved")
+        utxo_test_removal_replaced = make_utxo(node, int(1.1*COIN))
+
+        self.log.info(
+            "Testing ZMQ publisher mempoolremoved with reason REPLACED")
+        subscriber = ZMQSubscriber(socket, topic)
+        self.restart_node(0, [arg_accept_non_standard, arg_zmq_mempoolremoved])
+        # Relax so that the subscriber is ready before publishing zmq messages
+        sleep(0.2)
+        socket.connect(address)
+
+        self.log.info("Create transaction that will be replaced.")
+        tx1a = CTransaction()
+        tx1a.vin = [CTxIn(utxo_test_removal_replaced, nSequence=0)]
+        tx1a.vout = [CTxOut(1 * COIN, CScript([b'a' * 35]))]
+        tx1a_hex = tx1a.serialize().hex()
+        replaced_txid = node.sendrawtransaction(tx1a_hex, 0)
+
+        self.log.info("Create transaction with an extra 0.1 BTC in fees.")
+        tx1b = CTransaction()
+        tx1b.vin = [CTxIn(utxo_test_removal_replaced, nSequence=0)]
+        tx1b.vout = [CTxOut(int(0.9 * COIN), CScript([b'b' * 35]))]
+        tx1b_hex = tx1b.serialize().hex()
+        node.sendrawtransaction(tx1b_hex, 0)
+
+        self.log.info(
+            "We should be notified about the removed child transaction")
+        expected = {replaced_txid: 'REPLACED'}
+        subscriber.check_mempoolremoved_messages(expected)
+
+
+if __name__ == '__main__':
+    ZMQTest().main()
diff --git a/test/functional/interface_zmq_mempoolremove_sizelimit.py b/test/functional/interface_zmq_mempoolremove_sizelimit.py
new file mode 100644
index 000000000..60d333e2b
--- /dev/null
+++ b/test/functional/interface_zmq_mempoolremove_sizelimit.py
@@ -0,0 +1,84 @@
+#!/usr/bin/env python3
+# Copyright (c) 2015-2022 The Bitcoin Core developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""Test the ZMQ notification mempoolremoved to notify about low-fee
+transactions that were removed from the the mempool due to size limiting"""
+
+import zmq
+from time import sleep
+from random import randint
+
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import create_confirmed_utxos, create_lots_of_big_transactions, gen_return_txouts
+
+from test_framework.util_patched_zmq import ZMQSubscriber, removalReason
+
+
+class ZMQTest (BitcoinTestFramework):
+    def set_test_params(self):
+        self.num_nodes = 1
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_py3_zmq()
+        self.skip_if_no_bitcoind_zmq()
+        self.skip_if_no_wallet()
+
+    def run_test(self):
+        import zmq
+        self.ctx = zmq.Context()
+        try:
+            self.test_mempool_removed()
+        finally:
+            # Destroy the ZMQ context.
+            self.log.debug("Destroying ZMQ context")
+            self.ctx.destroy(linger=None)
+
+    def test_mempool_removed(self):
+        address = 'tcp://127.0.0.1:{}'.format(randint(20000, 50000))
+        socket = self.ctx.socket(zmq.SUB)
+        socket.set(zmq.RCVTIMEO, 60000)
+        topic = b"mempoolremoved"
+
+        arg_zmq_mempoolremoved = "-zmqpub%s=%s" % (topic.decode(), address)
+
+        node0 = self.nodes[0]
+
+        self.log.info("Testing ZMQ publisher mempoolremoved")
+        subscriber = ZMQSubscriber(socket, topic)
+        self.restart_node(0, ["-acceptnonstdtxn=1", "-maxmempool=5",
+                          "-spendzeroconfchange=0", arg_zmq_mempoolremoved])
+        sleep(0.2)
+        socket.connect(address)
+
+        self.log.info("Testing removal reason SIZELIMIT")
+
+        txouts = gen_return_txouts()
+        relayfee = node0.getnetworkinfo()['relayfee']
+        utxos = create_confirmed_utxos(relayfee, node0, 91)
+
+        self.log.info('Create a mempool tx that will be evicted')
+        us0 = utxos.pop()
+        inputs = [{"txid": us0["txid"], "vout": us0["vout"]}]
+        outputs = {node0.getnewaddress(): 0.0001}
+        tx = node0.createrawtransaction(inputs, outputs)
+        node0.settxfee(relayfee)  # specifically fund this tx with low fee
+        txF = node0.fundrawtransaction(tx)
+        node0.settxfee(0)  # return to automatic fee selection
+        txFS = node0.signrawtransactionwithwallet(txF['hex'])
+        txid = node0.sendrawtransaction(txFS['hex'])
+
+        base_fee = relayfee*100
+        for i in range(3):
+            create_lots_of_big_transactions(
+                node0, txouts, utxos[30*i:30*i+30], 30, (i+1)*base_fee)
+
+        self.log.info('The tx should be evicted by now')
+        # The ZMQ interface should receive the evicted transaction as the
+        # first of multiple evicted transactions
+        expected = {txid: "SIZELIMIT"}
+        subscriber.check_mempoolremoved_messages(expected)
+
+
+if __name__ == '__main__':
+    ZMQTest().main()
diff --git a/test/functional/interface_zmq_mempoolreplace.py b/test/functional/interface_zmq_mempoolreplace.py
new file mode 100644
index 000000000..9a00dc992
--- /dev/null
+++ b/test/functional/interface_zmq_mempoolreplace.py
@@ -0,0 +1,103 @@
+#!/usr/bin/env python3
+# Copyright (c) 2015-2019 The Bitcoin Core developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""Test the ZMQ publisher mempoolreplaced to notify us on a transaction that
+was replaced by another."""
+
+
+import struct
+from io import BytesIO
+from time import sleep, time
+from random import randint
+
+from feature_rbf import make_utxo
+from test_framework.address import ADDRESS_BCRT1_UNSPENDABLE
+from test_framework.messages import (
+    COIN,
+    COutPoint,
+    CTransaction,
+    CTxIn,
+    CTxOut
+)
+from test_framework.script import CScript
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import (
+    assert_equal, assert_raises_rpc_error, find_vout_for_address)
+from test_framework.util_patched_zmq import ZMQSubscriber, removalReason
+
+
+class ZMQTest (BitcoinTestFramework):
+    def set_test_params(self):
+        self.num_nodes = 1
+        self.extra_args = [["-acceptnonstdtxn=1"]]
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_py3_zmq()
+        self.skip_if_no_bitcoind_zmq()
+        self.skip_if_no_wallet()
+
+    def run_test(self):
+        import zmq
+        self.ctx = zmq.Context()
+        try:
+            self.test_mempool_replaced()
+        finally:
+            # Destroy the ZMQ context.
+            self.log.debug("Destroying ZMQ context")
+            self.ctx.destroy(linger=None)
+
+    def test_mempool_replaced(self):
+        import zmq
+        address = 'tcp://127.0.0.1:{}'.format(randint(20000, 50000))
+        socket = self.ctx.socket(zmq.SUB)
+        socket.set(zmq.RCVTIMEO, 60000)
+        topic = b"mempoolreplaced"
+
+        arg_zmq_mempoolreplaced = "-zmqpub%s=%s" % (topic.decode(), address)
+        arg_accept_non_standard = "-acceptnonstdtxn=1"
+
+        node = self.nodes[0]
+
+        # create utxo set before we start to listen on mempoolreplaced
+        utxo_value = 1.1*COIN
+        utxo_test_replaced = make_utxo(node, int(utxo_value))
+
+        self.log.info("Testing ZMQ publisher mempoolreplaced")
+        subscriber = ZMQSubscriber(socket, topic)
+        self.restart_node(
+            0, [arg_accept_non_standard, arg_zmq_mempoolreplaced])
+        # Relax so that the subscriber is ready before publishing zmq messages
+        sleep(0.2)
+        socket.connect(address)
+
+        self.log.info("Sending transaction that will be replaced")
+        replaced = CTransaction()
+        replaced.vin = [CTxIn(utxo_test_replaced, nSequence=0)]
+        replaced.vout = [CTxOut(1 * COIN, CScript([b'a' * 35]))]
+        replaced_hex = replaced.serialize().hex()
+        replaced_txid = node.sendrawtransaction(replaced_hex, 0)
+
+        self.log.info(
+            "Sending transaction with extra fees that will be the replacement")
+        replacement = CTransaction()
+        replacement.vin = [CTxIn(utxo_test_replaced, nSequence=0)]
+        replacement.vout = [CTxOut(int(0.9 * COIN), CScript([b'b' * 35]))]
+        replacement_hex = replacement.serialize().hex()
+        replacement_txid = node.sendrawtransaction(replacement_hex, 0)
+
+        self.log.info(
+            "Testing that the ZMQ interface receives the replace event")
+        r_replaced_txid, r_replaced_rawtx, r_replaced_tx_fee, r_replacement_txid, r_replacement_rawtx, r_replacement_tx_fee = subscriber.receive_multi_payload()
+        assert_equal(replaced_txid, r_replaced_txid.hex())
+        assert_equal(replaced_hex, r_replaced_rawtx.hex())
+        assert_equal(int(
+            utxo_value) - replaced.vout[0].nValue, int(struct.unpack("<q", r_replaced_tx_fee)[0]))
+        assert_equal(replacement_txid, r_replacement_txid.hex())
+        assert_equal(replacement_hex, r_replacement_rawtx.hex())
+        assert_equal(int(utxo_value) - replacement.vout[0].nValue, int(
+            struct.unpack("<q", r_replacement_tx_fee)[0]))
+
+
+if __name__ == '__main__':
+    ZMQTest().main()
diff --git a/test/functional/test_framework/util_patched_zmq.py b/test/functional/test_framework/util_patched_zmq.py
new file mode 100644
index 000000000..f59162e53
--- /dev/null
+++ b/test/functional/test_framework/util_patched_zmq.py
@@ -0,0 +1,98 @@
+#!/usr/bin/env python3
+"""Utility functionality for the patched ZMQ interface."""
+
+import struct
+import time
+from io import BytesIO
+
+import zmq
+
+from test_framework.messages import COutPoint, CTransaction
+from test_framework.util import assert_equal
+
+removalReason = {
+    'EXPIRY': 0,
+    'SIZELIMIT': 1,
+    'REORG': 2,
+    'BLOCK': 3,
+    'CONFLICT': 4,
+    'REPLACED': 5,
+}
+
+
+class ZMQSubscriber:
+    def __init__(self, socket, topic):
+        self.sequence = 0
+        self.socket = socket
+        self.topic = topic
+        self.socket.setsockopt(zmq.SUBSCRIBE, self.topic)
+
+    def receive_multi_payload(self):
+        """receives a multipart zmq message with zero, one or multiple payloads
+        and checks the topic and sequence number"""
+        msg = self.socket.recv_multipart()
+
+        # Message should consist of at least three parts
+        # (topic, timestamp and sequence)
+        assert(len(msg) >= 3)
+        topic = msg[0]
+        timestamp = msg[1]
+        sequence = msg[-1]
+
+        # Topic should match the subscriber topic.
+        assert_equal(topic, self.topic)
+
+        # Timestamp should be roughly in the range of the current timestamp.
+        timestamp = struct.unpack('<q', timestamp)[-1]
+        timestamp = timestamp / 1000  # convert to seconds
+        diff_seconds = time.time() - timestamp
+        assert diff_seconds < 5  # seconds
+        assert diff_seconds > -5  # seconds
+
+        # Sequence should be incremental.
+        assert_equal(struct.unpack('<I', sequence)[-1], self.sequence)
+        self.sequence += 1
+        return msg[2:-1]
+
+    def receive_mempoolremoved_message(self):
+        """Retrieves a two-payload ZMQ message from the topic mempoolremoved
+        containing the rawtransaction and the removal reason and returns the txid
+        and the removal reason"""
+        assert_equal(self.topic, b'mempoolremoved')
+
+        # Should receive a payload with three elements (txid, rawtx, removal reason)
+        payload = self.receive_multi_payload()
+        assert_equal(3, len(payload))
+
+        # First payload element should be the txid
+        r_txid = payload[0]
+
+        # Second payload element should be the raw transaction
+        r_rawtx = payload[1]
+        tx = CTransaction()
+        tx.deserialize(BytesIO(r_rawtx))
+        tx.calc_sha256()
+        assert_equal(r_txid.hex(), tx.hash)
+
+        # Second payload element should be the removal reason
+        reason = struct.unpack('<i', payload[2])[-1]
+
+        return [tx.hash, reason]
+
+    def discard_mempoolremoved_message_block(self):
+        """Retrieves one ZMQ message from the subscriber and checks that
+        it's a transaction removed from the mempool because it confirmed in a
+        block and discards it."""
+
+        assert_equal(self.topic, b'mempoolremoved')
+        _, reason = self.receive_mempoolremoved_message()
+        assert_equal(removalReason["BLOCK"], reason)
+
+    def check_mempoolremoved_messages(self, expected):
+        """checks that the in 'expected' defined txid-reason tuples arrive"""
+        for _ in range(len(expected)):
+            txhash, reason = self.receive_mempoolremoved_message()
+            assert_equal(True, txhash in expected)
+            assert_equal(removalReason[expected[txhash]], reason)
+            del expected[txhash]
+        assert_equal(0, len(expected))
diff --git a/test/functional/test_runner.py b/test/functional/test_runner.py
index 725706947..81e43f186 100755
--- a/test/functional/test_runner.py
+++ b/test/functional/test_runner.py
@@ -188,6 +188,18 @@ BASE_SCRIPTS = [
     'p2p_getdata.py',
     'p2p_addrfetch.py',
     'rpc_net.py',
+    'interface_zmq_mempooladded.py',
+    'interface_zmq_mempoolremove_block.py',
+    'interface_zmq_mempoolremove_conflict.py',
+    'interface_zmq_mempoolremove_expiry.py',
+    'interface_zmq_mempoolremove_reorg.py',
+    'interface_zmq_mempoolremove_replaced.py',
+    'interface_zmq_mempoolremove_sizelimit.py',
+    'interface_zmq_mempoolreplace.py',
+    'interface_zmq_mempoolconfirmed.py',
+    'interface_zmq_chaintipchanged.py',
+    'interface_zmq_chainblockconnected.py',
+    'interface_zmq_chainheaderadded.py',
     'wallet_keypool.py --legacy-wallet',
     'wallet_keypool.py --descriptors',
     'wallet_descriptor.py --descriptors',
